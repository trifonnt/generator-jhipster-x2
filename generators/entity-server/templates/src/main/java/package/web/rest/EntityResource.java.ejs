<%#
 Copyright 2013-2020 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%><%- include('../../common/functions.ejs') -%>
package <%= packageName %>.web.rest;

<%_
const viaService = service !== 'no';
let isUsingMapsId = false;
let mapsIdAssoc;
for (idx in relationships) {
    isUsingMapsId = relationships[idx].useJPADerivedIdentifier === true;
    if (isUsingMapsId) {
        mapsIdAssoc = relationships[idx];
        break;
    }
}
let manyToManyWithUser = false;
for (idx in relationships) {
    if (relationships[idx].otherEntityName === 'user' && relationships[idx].relationshipType === 'many-to-many') {
        manyToManyWithUser = true;
        break;
    }
}
_%>
<%_ if (dto !== 'mapstruct' || service === 'no') { _%>
import <%= packageName %>.domain.<%= asEntity(entityClass) %>;
<%_ } _%>
<%_ if (service !== 'no') { _%>
import <%= packageName %>.service.<%= entityClass %>Service;
	<%_ if (templateFactory) { _%>
import <%= packageName %>.service.<%= entityClass %>TemplateService; //@Trifon
import <%= packageName %>.service.mapper.tmpl.<%= entityClass %>TmplMapper; //@Trifon
import <%= packageName %>.service.UserService; //@Trifon
import <%= packageName %>.domain.User; //@Trifon
	<%_ } _%>
<%_ } else { _%>
import <%= packageName %>.repository.<%= entityClass %>Repository;
    <%_ if (isUsingMapsId === true) { _%>
import <%= packageName %>.repository.<%= mapsIdAssoc.otherEntityNameCapitalized %>Repository;
    <%_ } _%>
    <%_ if (searchEngine === 'elasticsearch') { _%>
import <%= packageName %>.repository.search.<%= entityClass %>SearchRepository;
    <%_ } _%>
<%_ } _%>
<%_ if (saveUserSnapshot) { _%>
import <%= packageName %>.repository.UserRepository;
<%_ } _%>
import <%= packageName %>.web.rest.errors.BadRequestAlertException;
import <%=packageName%>.web.rest.errors.EntityNotFoundException; //@Trifon
import <%=packageName%>.web.rest.common.JsonPatcher; //@Trifon
import <%=packageName%>.web.rest.common.RestMediaType; //@Trifon
import <%=packageName%>.service.dto.IdArrayDTO; //@Trifon
<%_ for (idx in relationships) {
        // @Trifon - relationship with Image entity
        const otherEntityRelationshipName = relationships[idx].otherEntityRelationshipName;
        const otherEntityRelationshipNamePlural = relationships[idx].otherEntityRelationshipNamePlural;
        const relationshipName = relationships[idx].relationshipName;
        const relationshipNamePlural = relationships[idx].relationshipNamePlural;
        const relationshipFieldName = relationships[idx].relationshipFieldName;
        const relationshipFieldNamePlural = relationships[idx].relationshipFieldNamePlural;
        const joinTableName = getJoinTableName(name, relationshipName, prodDatabaseType);
        const relationshipType = relationships[idx].relationshipType;
        const relationshipValidate = relationships[idx].relationshipValidate;
        const relationshipRequired = relationships[idx].relationshipRequired;
        const otherEntityName = relationships[idx].otherEntityName;
        const otherEntityNameCapitalized = relationships[idx].otherEntityNameCapitalized;
        const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'one-to-many' && otherEntityName === 'image') { _%>
import <%=packageName%>.service.ImageService; //@Trifon
<%_ } } _%>
import com.github.fge.jsonpatch.JsonPatchException; //@Trifon
import io.swagger.annotations.Api; //@Trifon
<%_ if (dto === 'mapstruct') { _%>
import <%= packageName %>.service.dto.*; //@Trifon
import <%= packageName %>.service.dto.<%= asDto(entityClass) %>;
    <%_ if (service === 'no') { _%>
import <%= packageName %>.service.mapper.<%= entityClass %>Mapper;
    <%_ } _%>
<%_ } _%>
<%_ if (jpaMetamodelFiltering) {  _%>
import <%= packageName %>.service.dto.<%= entityClass %>Criteria;
import <%= packageName %>.service.<%= entityClass %>QueryService;
<%_ } _%>
<%_ if (requiredRoleForCreate || requiredRoleForRead || requiredRoleForUpdate || requiredRoleForDelete) { _%>
import <%= packageName %>.security.AuthoritiesConstants; //@Trifon
<%_ } _%>

import io.github.jhipster.web.util.HeaderUtil;
<%_ if (pagination !== 'no') { _%>
import io.github.jhipster.web.util.PaginationUtil;
<%_ } _%>
import io.github.jhipster.web.util.<% if (reactive) { %>reactive.<% } %>ResponseUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
<%_ if (pagination !== 'no') { _%>
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
    <%_ if (reactive) { _%>
import org.springframework.data.domain.PageImpl;
    <%_ } _%>
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
    <%_ if (reactive) { _%>
import org.springframework.http.server.reactive.ServerHttpRequest;
    <%_ } _%>
    <%_ if (!reactive) { _%>
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
    <%_ } else { _%>
import org.springframework.web.util.UriComponentsBuilder;
    <%_ } _%>
<%_ } else if (reactiveRepositories) { _%>
import org.springframework.http.HttpStatus;
<%_ } _%>
<%_ if (reactiveRepositories) { _%>
import org.springframework.http.MediaType;
<%_ } _%>
import org.springframework.http.MediaType; //@Trifon
import org.springframework.http.ResponseEntity;
import org.springframework.beans.factory.annotation.Autowired; //@Trifon
<%_ if (requiredRoleForCreate || requiredRoleForRead || requiredRoleForUpdate || requiredRoleForDelete) { _%>
import org.springframework.security.access.prepost.PreAuthorize; //@Trifon
<%_ } _%>
import org.springframework.web.multipart.MultipartFile; //@Trifon
<%_ if (!viaService && !saveUserSnapshot) { _%>
import org.springframework.transaction.annotation.Transactional;
<%_ } _%>
import org.springframework.web.bind.annotation.*;
import java.io.BufferedReader; //@Trifon
import java.io.InputStreamReader; //@Trifon
import java.io.IOException; //@Trifon
<%_ if (reactiveRepositories) { _%>
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
<%_ } _%>

<%_ if (validation || !validation) { _%>
import javax.validation.Valid; //@Trifon
<%_ } _%>
import java.net.URI;
import java.net.URISyntaxException;
<%_ if (pagination === 'no' && dto === 'mapstruct' && !viaService && fieldsContainNoOwnerOneToOne === true) { _%>
import java.util.LinkedList;
<%_ } _%>
<%_ if (pagination !== 'no' && reactive) { _%>
import java.util.ArrayList;
<%_ } _%>
import java.util.Map; //@Trifon
import java.util.List;
<%_ if (isUsingMapsId === true) { _%>
import java.util.Objects;
<%_ } _%>
import java.util.Optional;
<%_ if (databaseType === 'cassandra') { _%>
import java.util.UUID;
<%_ } _%>
<%_ if ((searchEngine !== false && !reactive) || fieldsContainNoOwnerOneToOne === true) { _%>
    <%_ if (!viaService) { _%>
import java.util.stream.Collectors;
    <%_ } _%>
import java.util.stream.StreamSupport;
<%_ } _%>
<%_ if (searchEngine === 'elasticsearch' && !reactive) { _%>

import static org.elasticsearch.index.query.QueryBuilders.*;
<%_ } _%>

/**
 * REST controller for managing {@link <%= packageName %>.domain.<%= asEntity(entityClass) %>}.
 */
@RestController
@RequestMapping("/api")
<%_ if (databaseType === 'sql' && !viaService && !saveUserSnapshot) { _%>
@Transactional
<%_ } _%>
@Api(tags={"<%= entityApiUrl %>"}) //@Trifon
public class <%= entityClass %>Resource {

    private final Logger log = LoggerFactory.getLogger(<%= entityClass %>Resource.class);

<%_ if (templateFactory) { _%>
	@Autowired
	private UserService userService; //@Trifon
	@Autowired
	private <%= entityClass %>TemplateService <%= entityInstance %>TemplateService; //@Trifon
	@Autowired
	private <%= entityClass %>TmplMapper <%= entityInstance %>TmplMapper; //@Trifon
<%_ } _%>
	//@Trifon
	@Autowired
	private JsonPatcher jsonPatcher;
<%_ for (idx in relationships) {
        // @Trifon - relationship with Image entity
        const otherEntityRelationshipName = relationships[idx].otherEntityRelationshipName;
        const otherEntityRelationshipNamePlural = relationships[idx].otherEntityRelationshipNamePlural;
        const relationshipName = relationships[idx].relationshipName;
        const relationshipNamePlural = relationships[idx].relationshipNamePlural;
        const relationshipFieldName = relationships[idx].relationshipFieldName;
        const relationshipFieldNamePlural = relationships[idx].relationshipFieldNamePlural;
        const joinTableName = getJoinTableName(name, relationshipName, prodDatabaseType);
        const relationshipType = relationships[idx].relationshipType;
        const relationshipValidate = relationships[idx].relationshipValidate;
        const relationshipRequired = relationships[idx].relationshipRequired;
        const otherEntityName = relationships[idx].otherEntityName;
        const otherEntityNameCapitalized = relationships[idx].otherEntityNameCapitalized;
        const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'one-to-many' && otherEntityName === 'image') { _%>
	@Autowired
	private ImageService imageService; //@Trifon
<%_ } } _%>
<%_ if (!readOnly) { _%>

    <%_ let entityName = entityInstance;
    if (clientRootFolder && !skipUiGrouping) {
        entityName = _.camelCase(`${clientRootFolder}${entityClass}`);
    } _%>
    public static final String ENTITY_NAME = "<%= entityName %>"; //@Trifon

    @Value("${jhipster.clientApp.name}")
    private String applicationName;
<%_ } _%>
    <%_
    const instanceType = (dto === 'mapstruct') ? asDto(entityClass) : asEntity(entityClass);
    const instanceName = (dto === 'mapstruct') ? asDto(entityInstance) : asEntity(entityInstance);
    const mapper = entityInstance  + 'Mapper';
    const entityToDtoReference = mapper + '::' + 'toDto';
    _%><%- include('../../common/inject_template', {viaService: viaService, constructorName: entityClass + 'Resource', queryService: jpaMetamodelFiltering, isUsingMapsId: isUsingMapsId, mapsIdAssoc: mapsIdAssoc, isController: true}); -%>
<%_ if (!readOnly) { _%>

    /**
     * {@code POST  /<%= entityApiUrl %>} : Create a new <%= entityInstance %>.
     *
     * @param <%= instanceName %> the <%= instanceName %> to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new <%= instanceName %>, or with status {@code 400 (Bad Request)} if the <%= entityInstance %> has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/<%= entityApiUrl %>")
    <%_ if (requiredRoleForCreate) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")")
    <%_ } _%>
    public <% if (reactive) { %>Mono<<% } %>ResponseEntity<<%= instanceType %>><% if (reactive) { %>><% } %> create<%= entityClass %>(<% if (validation) { %>@Valid <% } %>@RequestBody <%= instanceType %> <%= instanceName %>) throws URISyntaxException {
        log.debug("REST request to save <%= entityClass %> : {}", <%= instanceName %>);
        if (<%= instanceName %>.getId() != null) {
            throw new BadRequestAlertException("A new <%= entityInstance %> cannot already have an ID", ENTITY_NAME, "idexists");
        }
        <%_ if (saveUserSnapshot) { _%>
            <%_ if (manyToManyWithUser) { _%>
        if (<%= instanceName %>.getUsers() != null) {
            // Save users in case they are new and only exists in gateway
            userRepository.saveAll(<%= instanceName %>.getUsers());
        }
            <%_ } else { _%>
        if (<%= instanceName %>.getUser() != null) {
            // Save user in case it's new and only exists in gateway
            userRepository.save(<%= instanceName %>.getUser());
        }
            <%_ } _%>
        <%_ } _%>
        <%_ if (databaseType === 'cassandra') { _%>
        <%= instanceName %>.setId(UUID.randomUUID());
        <%_ } _%>
        <%_ if (!reactive) { _%>
<%- include('../../common/save_template', {asEntity, asDto, viaService: viaService, returnDirectly: false, isUsingMapsId: isUsingMapsId, mapsIdAssoc: mapsIdAssoc, isController: true}); -%>
<%_ for (idx in relationships) {
        // @Trifon - relationship with Image entity
        const otherEntityRelationshipName = relationships[idx].otherEntityRelationshipName;
        const otherEntityRelationshipNamePlural = relationships[idx].otherEntityRelationshipNamePlural;
        const relationshipName = relationships[idx].relationshipName;
        const relationshipNamePlural = relationships[idx].relationshipNamePlural;
        const relationshipFieldName = relationships[idx].relationshipFieldName;
        const relationshipFieldNamePlural = relationships[idx].relationshipFieldNamePlural;
        const joinTableName = getJoinTableName(name, relationshipName, prodDatabaseType);
        const relationshipType = relationships[idx].relationshipType;
        const relationshipValidate = relationships[idx].relationshipValidate;
        const relationshipRequired = relationships[idx].relationshipRequired;
        const otherEntityName = relationships[idx].otherEntityName;
        const otherEntityNameCapitalized = relationships[idx].otherEntityNameCapitalized;
        const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'one-to-many' && otherEntityName === 'image') { _%>
        // @Trifon - Iterate all images and create them
        for (ImageDTO image : <%= instanceName %>.get<%= firstToUpper(relationshipFieldNamePlural) %>()) {
        	image.set<%= firstToUpper(otherEntityRelationshipName) %>Id(result.getId());
        	ImageDTO savedImage = imageService.save(image);
        	result.get<%= firstToUpper(relationshipFieldNamePlural) %>().add(savedImage);
        }
<%_ } } _%>
        return ResponseEntity.created(new URI("/api/<%= entityApiUrl %>/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, result.getId()<% if (primaryKeyType !== 'String') { %>.toString()<% } %>))
            .body(result);
        <%_ } else { _%>
<%- include('../../common/save_reactive_template', {asEntity, asDto, viaService: viaService, returnDirectly: false}); -%>
            .map(result -> {
                try {
                    return ResponseEntity.created(new URI("/api/<%= entityApiUrl %>/" + result.getId()))
                        .headers(HeaderUtil.createEntityCreationAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, result.getId()<% if (primaryKeyType !== 'String') { %>.toString()<% } %>))
                        .body(result);
                } catch (URISyntaxException e) {
                    throw new RuntimeException(e);
                }
            });
        <%_ } _%>
    }

    /**
     * {@code PUT  /<%= entityApiUrl %>} : Updates an existing <%= entityInstance %>.
     *
     * @param <%= instanceName %> the <%= instanceName %> to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated <%= instanceName %>,
     * or with status {@code 400 (Bad Request)} if the <%= instanceName %> is not valid,
     * or with status {@code 500 (Internal Server Error)} if the <%= instanceName %> couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/<%= entityApiUrl %>")
    <%_ if (requiredRoleForUpdate) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForUpdate %> + "\")")
    <%_ } _%>
    public <% if (reactive) { %>Mono<<% } %>ResponseEntity<<%= instanceType %>><% if (reactive) { %>><% } %> update<%= entityClass %>(<% if (validation) { %>@Valid <% } %>@RequestBody <%= instanceType %> <%= instanceName %>) throws URISyntaxException {
        log.debug("REST request to update <%= entityClass %> : {}", <%= instanceName %>);
        if (<%= instanceName %>.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        <%_ if (saveUserSnapshot) { _%>
            <%_ if (manyToManyWithUser) { _%>
        if (<%= instanceName %>.getUsers() != null) {
            // Save users in case they are new and only exists in gateway
            userRepository.saveAll(<%= instanceName %>.getUsers());
        }
            <%_ } else { _%>
        if (<%= instanceName %>.getUser() != null) {
            // Save user in case it's new and only exists in gateway
            userRepository.save(<%= instanceName %>.getUser());
        }
            <%_ } _%>
        <%_ } _%>
    <%_ if (!reactive) { _%>
<%- include('../../common/save_template', {asEntity, asDto, viaService: viaService, returnDirectly: false, isUsingMapsId: false, mapsIdAssoc: mapsIdAssoc}); -%>
        return ResponseEntity.ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, <%= instanceName %>.getId()<% if (primaryKeyType !== 'String') { %>.toString()<% } %>))
            .body(result);
    <%_ } else { _%>
<%- include('../../common/save_reactive_template', {asEntity, asDto, viaService: viaService, returnDirectly: false}); -%>
            .switchIfEmpty(Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND)))
            .map(result -> ResponseEntity.ok()
                .headers(HeaderUtil.createEntityUpdateAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, result.getId()<% if (primaryKeyType !== 'String') { %>.toString()<% } %>))
                .body(result)
            );
    <%_ } _%>
    }
<%_ } _%>

    // @Trifon
    // JSON PATCH - V3
    // echo '[{ "op": "replace", "path": "/description", "value": "Patched Description" }]' | http PATCH :10000/api/<%= entityApiUrl %>/1 Content-Type:application/json-patch+json
    /**
     * PATCH  /<%= entityApiUrl %>/:id : Patches an existing <%= entityInstance %>.
     *
     * @param <%= instanceName %> the <%= instanceName %> to update
     * @return the ResponseEntity with status 200 (OK) and with body the updated <%= instanceName %>,
     * or with status 400 (Bad Request) if the <%= instanceName %> is not valid,
     * or with status 500 (Internal Server Error) if the <%= instanceName %> couldn't be updated
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */
    @PatchMapping(value = "/<%= entityApiUrl %>/{id}", 
    	consumes = RestMediaType.APPLICATION_PATCH_JSON_VALUE,
		produces = MediaType.APPLICATION_JSON_VALUE)
    <%_ if (requiredRoleForUpdate) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForUpdate %> + "\")")
    <%_ } _%>
    public ResponseEntity<<%= instanceType %>> partialUpdate<%= entityClass %>(@PathVariable Long id, @RequestBody String patchCommand) {
        log.debug("REST request to PATCH <%= entityClass %> : {}", id);

		<%= instanceType %> existing<%= instanceType %> = <%= entityInstance %>Service.findOne(id).orElseThrow(() -> new EntityNotFoundException());
		<%= instanceType %> <%= instanceName %> = null;
		try {
			<%= instanceName %> = (<%= instanceType %>)jsonPatcher.patch(patchCommand, existing<%= instanceType %>).get();
		} catch (RuntimeException ex) {
			if (JsonPatchException.class.isAssignableFrom(ex.getCause().getClass())) {
				log.error(ex.getMessage());
			}
		}

<%- include('../../common/save_template', {asEntity, asDto, viaService: viaService, returnDirectly: false, isUsingMapsId: false, mapsIdAssoc: mapsIdAssoc}); -%>
		return ResponseEntity.ok()
			.headers(HeaderUtil.createEntityUpdateAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, result.getId()<% if (primaryKeyType !== 'String') { %>.toString()<% } %>))
			.body(result);
	}
    /**
     * {@code GET  /<%= entityApiUrl %>} : get all the <%= entityInstancePlural %>.
     *
    <%_ if (pagination !== 'no') { _%>
     * @param pageable the pagination information.
        <%_ if (reactive) { _%>
     * @param request a {@link ServerHttpRequest} request.
        <%_ } _%>
    <%_ } _%>
    <%_ if (!jpaMetamodelFiltering && fieldsContainOwnerManyToMany) { _%>
     * @param eagerload flag to eager load entities from relationships (This is applicable for many-to-many).
     <%_ } _%>
     <%_ if (jpaMetamodelFiltering) { _%>
     * @param criteria the criteria which the requested entities should match.
     <%_ } else if (fieldsContainNoOwnerOneToOne) { _%>
     * @param filter the filter of the request.
     <%_ } _%>
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of <%= entityInstancePlural %> in body.
     */
    @GetMapping("/<%= entityApiUrl %>")
    <%_ if (databaseType === 'sql' && isUsingMapsId === true && !viaService) { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    <%_ if (requiredRoleForRead) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForRead %> + "\")")
    <%_ } _%>
<%- include('../../common/get_all_template', {asEntity, asDto, viaService}); -%>

    <%_ if (reactiveRepositories && pagination === 'no') { _%>
    /**
     * {@code GET  /<%= entityApiUrl %>} : get all the <%= entityInstancePlural %> as a stream.
     * @return the {@link Flux} of <%= entityInstancePlural %>.
     */
    @GetMapping(value = "/<%= entityApiUrl %>", produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
    <%_ if (databaseType === 'sql' && isUsingMapsId === true && !viaService) { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    <%_ if (requiredRoleForRead) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForRead %> + "\")") //@Trifon
    <%_ } _%>
    public Flux<<%= instanceType %>> getAll<%= entityClassPlural %>AsStream() {
        log.debug("REST request to get all <%= entityClassPlural %> as a stream");
        <%_ if (viaService) { _%>
        return <%= entityInstance %>Service.findAll();
        <%_ } else { _%>
        return <%= entityInstance %>Repository.findAll()<%_ if (dto === 'mapstruct') { _%>.map(<%= entityToDtoReference %>)<%_ } _%>;
        <%_ } _%>
    }

    <%_ } _%>
    /**
     * {@code GET  /<%= entityApiUrl %>/:id} : get the "id" <%= entityInstance %>.
     *
     * @param id the id of the <%= instanceName %> to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the <%= instanceName %>, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/<%= entityApiUrl %>/{id}")
    <%_ if (databaseType === 'sql' && isUsingMapsId === true && !viaService) { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    <%_ if (requiredRoleForRead) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForRead %> + "\")") //@Trifon
    <%_ } _%>
    public <% if (reactive) { %>Mono<<% } %>ResponseEntity<<%= instanceType %>><% if (reactive) { %>><% } %> get<%= entityClass %>(@PathVariable <%= primaryKeyType %> id) {
        log.debug("REST request to get <%= entityClass %> : {}", id);<%- include('../../common/get_template', {asEntity, asDto, viaService, returnDirectly:false}); -%>
        return ResponseUtil.wrapOrNotFound(<%= instanceName %>);
    }

<%_ if (templateFactory) { _%>
<%_ } else { _%>
	/**
	 * GET  /<%= entityApiUrl %>/template : get the Template JSON for <%= entityInstance %>.
	 *
	 * @return the ResponseEntity with status 200 (OK) and with body the <%= instanceName %>, or with status 404 (Not Found)
	 */
	@GetMapping("/<%= entityApiUrl %>/template")
<%_ if (requiredRoleForCreate) { _%>
	@PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")") //@Trifon
<%_ } _%>
	public ResponseEntity<<%= instanceType %>> getTemplate<%= entityClass %>() {
		log.debug("REST request to get Template for <%= entityClass %>");

		<%= instanceType %> <%= instanceName %> = new <%= instanceType %>();
		// TODO - Fields which are sequence controlled should be with <GENERATED>
		if (<%= instanceName %>.getValue() == null || <%= instanceName %>.getValue().isEmpty()) {
			<%= instanceName %>.setValue("<GENERATED>");
		}

		return ResponseEntity.ok().body(<%= instanceName %>);
	}
<%_ } _%>
<%_ if (templateFactory) { _%>
	/**
	 * GET  /<%= entityApiUrl %>/template : get the Template JSON for <%= entityInstance %>.
	 *
	 * @return the ResponseEntity with status 200 (OK) and with body the <%= instanceName %>, or with status 404 (Not Found)
	 */
	@GetMapping("/<%= entityApiUrl %>/template")
<%_ if (requiredRoleForCreate) { _%>
	@PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")") //@Trifon
<%_ } _%>
	public ResponseEntity<<%= entityClass %>TemplateDTO> getTemplate<%= entityClass %>() {
		log.debug("REST request to get Template for <%= entityClass %>");

		// Search for <%= entityClass %>Template by:
		// 1) Currently loggedIn User
		// 2) null or SystemUser
		Optional<User> loggedInUser = userService.getUserWithAuthorities();
		Optional<<%= entityClass %>TemplateDTO> optional<%= entityClass %>TemplateDTO = Optional.empty();
		if (loggedInUser.isPresent()) {
			optional<%= entityClass %>TemplateDTO = <%= entityInstance %>TemplateService.findOneByUserId(loggedInUser.get().getId());
		}
		if (optional<%= entityClass %>TemplateDTO.isEmpty()) {
			optional<%= entityClass %>TemplateDTO = <%= entityInstance %>TemplateService.findOneByUserId(null);
		}
		<%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO = null;
		if (optional<%= entityClass %>TemplateDTO.isEmpty()) {
			<%= entityInstance %>TemplateDTO = new <%= entityClass %>TemplateDTO();
		} else {
			<%= entityInstance %>TemplateDTO = optional<%= entityClass %>TemplateDTO.get();
		}

		// TODO - Fields which are sequence controlled should be with <GENERATED>
		if (<%= entityInstance %>TemplateDTO.getValue() == null || <%= entityInstance %>TemplateDTO.getValue().isEmpty()) {
			<%= entityInstance %>TemplateDTO.setValue("<GENERATED>");
		}
		// Convert <%= entityClass %>TemplateDTO to <%= entityClass %>DTO!!!
//		<%= instanceName %> = <%= entityInstance %>TmplMapper.toDto(<%= entityInstance %>TemplateDTO);

		return ResponseEntity.ok().body(<%= entityInstance %>TemplateDTO);
	}

	/**
	 * POST  /<%= entityApiUrl %>/template : Create a new <%= entityClass %>Template.
	 *
	 * @return the ResponseEntity with status 200 (OK) and with body the <%= instanceName %>, or with status 404 (Not Found)
	 */
	@PostMapping("/<%= entityApiUrl %>/template")
	<%_ if (requiredRoleForCreate) { _%>
	@PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")")
	<%_ } _%>
	public ResponseEntity<<%= entityClass %>TemplateDTO> create<%= entityClass %>Template(@RequestBody <%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO) throws URISyntaxException {
		log.debug("REST request to create <%= entityClass %>Template : {}", <%= entityInstance %>TemplateDTO);
		if (<%= entityInstance %>TemplateDTO.getId() != null) {
			throw new BadRequestAlertException("A new <%= entityClass %>TemplateDTO cannot already have an ID", <%= entityClass %>TemplateResource.ENTITY_NAME, "idexists");
		}
		User loggedInUser = userService.getUserWithAuthorities().orElseThrow(() -> new EntityNotFoundException());

//		<%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO = <%= entityInstance %>TmplMapper.toTemplate(<%= instanceName %>);
		<%= entityInstance %>TemplateDTO.setUserId(loggedInUser.getId());

		// TODO - Fields which are sequence controlled should be with <GENERATED>
		if (<%= entityInstance %>TemplateDTO.getValue() == null || <%= entityInstance %>TemplateDTO.getValue().isEmpty()) {
			<%= entityInstance %>TemplateDTO.setValue("<GENERATED>");
		}

		<%= entityInstance %>TemplateDTO = <%= entityInstance %>TemplateService.save(<%= entityInstance %>TemplateDTO);

//		<%= instanceType %> result = <%= entityInstance %>TmplMapper.toDto(<%= entityInstance %>TemplateDTO);
		return ResponseEntity.ok().body(<%= entityInstance %>TemplateDTO);
	}

	/**
	 * {@code PUT  /<%= entityApiUrl %>/template} : Updates an existing <%= entityClass %>Template.
	 *
	 * @param <%= entityInstance %>TemplateDTO the <%= entityInstance %>TemplateDTO to update.
	 * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated <%= entityInstance %>TemplateDTO,
	 * or with status {@code 400 (Bad Request)} if the <%= instanceName %> is not valid,
	 * or with status {@code 500 (Internal Server Error)} if the <%= instanceName %> couldn't be updated.
	 * @throws URISyntaxException if the Location URI syntax is incorrect.
	 */
	@PutMapping("/<%= entityApiUrl %>/template")
	public ResponseEntity<<%= entityClass %>TemplateDTO> update<%= entityClass %>Template(@RequestBody <%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO) throws URISyntaxException {
		log.debug("REST request to update <%= entityClass %>Template : {}", <%= entityInstance %>TemplateDTO);

		User loggedInUser = userService.getUserWithAuthorities().orElseThrow(() -> new EntityNotFoundException());
		<%= entityClass %>TemplateDTO existing<%= entityClass %>TemplateDTO = <%= entityInstance %>TemplateService.findOneByUserId(loggedInUser.getId())
				.orElseThrow(() -> new EntityNotFoundException());

//		<%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO = <%= entityInstance %>TmplMapper.toTemplate(<%= instanceName %>);
		<%= entityInstance %>TemplateDTO.setId(existing<%= entityClass %>TemplateDTO.getId());
		<%= entityInstance %>TemplateDTO.setUserId(loggedInUser.getId());

		<%= entityInstance %>TemplateDTO = <%= entityInstance %>TemplateService.save(<%= entityInstance %>TemplateDTO);

//		<%= instanceType %> result = <%= entityInstance %>TmplMapper.toDto(<%= entityInstance %>TemplateDTO);
		return ResponseEntity.ok()
				.headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, <%= entityClass %>TemplateResource.ENTITY_NAME, <%= entityInstance %>TemplateDTO.getId().toString()))
				.body(<%= entityInstance %>TemplateDTO);
	}

	// JSON PATCH - V3
	// echo '[{ "op": "replace", "path": "/description", "value": "Patched Description" }]' | http PATCH :10000/api/<%= entityApiUrl %>/template Content-Type:application/json-patch+json
	/**
	 * PATCH  /<%= entityApiUrl %>/template : Patches an existing <%= entityClass %>Template.
	 *
	 * @param patchCommand the patchCommand to apply
	 * @return the ResponseEntity with status 200 (OK) and with body the updated <%= instanceType %>,
	 * or with status 400 (Bad Request) if the patchCommand is not valid,
	 * or with status 500 (Internal Server Error) if patchCommand can't be applied
	 * @throws URISyntaxException if the Location URI syntax is incorrect
	 */
	@PatchMapping(value = "/<%= entityApiUrl %>/template", 
		consumes = RestMediaType.APPLICATION_PATCH_JSON_VALUE,
		produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity<<%= entityClass %>TemplateDTO> partialUpdate<%= entityClass %>Template(@RequestBody String patchCommand) {
		log.debug("REST request to PATCH <%= entityClass %>Template, patch command : {}", patchCommand);

		User loggedInUser = userService.getUserWithAuthorities().orElseThrow(() -> new EntityNotFoundException());
		<%= entityClass %>TemplateDTO existing<%= entityClass %>TemplateDTO = <%= entityInstance %>TemplateService.findOneByUserId(loggedInUser.getId())
				.orElseThrow(() -> new EntityNotFoundException());
		<%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO = null;
		try {
			<%= entityInstance %>TemplateDTO = (<%= entityClass %>TemplateDTO)jsonPatcher.patch(patchCommand, existing<%= entityClass %>TemplateDTO).get();
		} catch (RuntimeException ex) {
			if (JsonPatchException.class.isAssignableFrom(ex.getCause().getClass())) {
				log.error(ex.getMessage());
			}
		}
		<%= entityInstance %>TemplateDTO.setId(existing<%= entityClass %>TemplateDTO.getId());
		<%= entityInstance %>TemplateDTO.setUserId(loggedInUser.getId());

		<%= entityInstance %>TemplateDTO = <%= entityInstance %>TemplateService.save(<%= entityInstance %>TemplateDTO);

//		<%= instanceType %> result = <%= entityInstance %>TmplMapper.toDto(<%= entityInstance %>TemplateDTO);
		return ResponseEntity.ok()
				.headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, <%= entityClass %>TemplateResource.ENTITY_NAME, <%= entityInstance %>TemplateDTO.getId().toString()))
				.body(<%= entityInstance %>TemplateDTO);
	}

	/**
	 * {@code DELETE  /<%= entityApiUrl %>/template} : delete the <%= entityClass %>Template.
	 *
	 * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
	 */
	@DeleteMapping("/<%= entityApiUrl %>/template")
	public ResponseEntity<Void> delete<%= entityClass %>Template() {
		log.debug("REST request to delete <%= entityClass %>Template.");

		User loggedInUser = userService.getUserWithAuthorities().orElseThrow(() -> new EntityNotFoundException());
		<%= entityClass %>TemplateDTO <%= entityInstance %>TemplateDTO = <%= entityInstance %>TemplateService.findOneByUserId(loggedInUser.getId())
				.orElseThrow(() -> new EntityNotFoundException());

		<%= entityInstance %>TemplateService.delete(<%= entityInstance %>TemplateDTO.getId());
		return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, <%= entityClass %>TemplateResource.ENTITY_NAME, <%= entityInstance %>TemplateDTO.getId().toString())).build();
	}
<%_ } // end if - "templateFactory"_%>
<%_ for (idx in relationships) {
        const otherEntityRelationshipName = relationships[idx].otherEntityRelationshipName;
        const otherEntityRelationshipNamePlural = relationships[idx].otherEntityRelationshipNamePlural;
        const relationshipName = relationships[idx].relationshipName;
        const relationshipNamePlural = relationships[idx].relationshipNamePlural;
        const relationshipNamePluralizedAndSpinalCased = _.kebabCase(relationshipNamePlural);
        const relationshipFieldName = relationships[idx].relationshipFieldName;
        const relationshipFieldNamePlural = relationships[idx].relationshipFieldNamePlural;
        const joinTableName = getJoinTableName(name, relationshipName, prodDatabaseType);
        const relationshipType = relationships[idx].relationshipType;
        const relationshipValidate = relationships[idx].relationshipValidate;
        const relationshipRequired = relationships[idx].relationshipRequired;
        const otherEntityName = relationships[idx].otherEntityName;
        const otherEntityNameCapitalized = relationships[idx].otherEntityNameCapitalized;
        const ownerSide = relationships[idx].ownerSide;
        if (relationshipType === 'one-to-many') { _%>

    @GetMapping("/<%= entityApiUrl %>/{id}/<%= relationshipNamePluralizedAndSpinalCased %>/template")
    <%_ if (requiredRoleForRead) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForRead %> + "\")") //@Trifon
    <%_ } _%>
    public ResponseEntity<<%= otherEntityNameCapitalized %>DTO> get<%= firstToUpper(relationshipName) %>Template(@PathVariable Long id) {
        log.debug("REST request to get Template for <%= firstToUpper(relationshipNamePlural) %> in <%= entityClass %> : {}", id);

        <%= instanceType %> <%= instanceName %> = <%= entityInstance %>Service.findOne(id).orElseThrow(() -> new EntityNotFoundException());

        <%= otherEntityNameCapitalized %>DTO <%= otherEntityName %>DTO = new <%= otherEntityNameCapitalized %>DTO();
        <%= otherEntityName %>DTO.set<%= firstToUpper(otherEntityRelationshipName) %>Id(<%= instanceName %>.getId());
        // Populate all automatically populated fields!
//      <%= otherEntityName %>DTO.setCode(...);

		HttpHeaders headers = HeaderUtil.createHiddenFieldsHeader("<%= firstToLower(entityClass) %>Id");

        return ResponseEntity.ok().headers(headers).body(<%= otherEntityName %>DTO);
    }
<%_ }
} _%>

<%_ if (!readOnly) { _%>
    /**
     * {@code DELETE  /<%= entityApiUrl %>/:id} : delete the "id" <%= entityInstance %>.
     *
     * @param id the id of the <%= instanceName %> to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/<%= entityApiUrl %>/{id}")
    <%_ if (reactive) { _%>
    @ResponseStatus(code = HttpStatus.NO_CONTENT)
    <%_ } _%>
    <%_ if (requiredRoleForDelete) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForDelete %> + "\")") //@Trifon
    <%_ } _%>
    public <% if (reactive) { %>Mono<<% } %>ResponseEntity<Void><% if (reactive) { %>><% } %> delete<%= entityClass %>(@PathVariable <%= primaryKeyType %> id) {
        log.debug("REST request to delete <%= entityClass %> : {}", id);
<%- include('../../common/delete_template', {viaService: viaService, fromResource: true}); -%>
    <%_ if (!reactive) { _%>
        return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, id<% if (primaryKeyType !== 'String') { %>.toString()<% } %>)).build();
    <%_ } else { _%>
        <%_ if (databaseType === 'couchbase') { _%>
            .then(Mono.just(ResponseEntity.noContent()
                .headers(HeaderUtil.createEntityDeletionAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, id<% if (primaryKeyType !== 'String') { %>.toString()<% } %>)).build())
            );
        <%_ } else { _%>
            .map(result -> ResponseEntity.noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, id<% if (primaryKeyType !== 'String') { %>.toString()<% } %>)).build()
        );
        <%_ } _%>
    <%_ } _%>
    }

	//@Trifon
    /**
     * DELETE  /<%= entityApiUrl %>/ : delete list of <%= entityInstancePlural %>.
     *
     * @param IdArrayDTO the list with <%= entityClass %> ids to delete
     * @return the ResponseEntity with status 200 (OK)
     */
    //   Delete multiple records using REST
    // - https://stackoverflow.com/questions/21863326/delete-multiple-records-using-rest
    @DeleteMapping("/<%= entityApiUrl %>")
    <%_ if (requiredRoleForDelete) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForDelete %> + "\")") //@Trifon
    <%_ } _%>
    public ResponseEntity<Void> deleteMultiple<%= entityClassPlural %>(@Valid @RequestBody IdArrayDTO idArrayDTO) {
        log.debug("REST request to delete MULTIPLE <%= entityClassPlural %> : {}", idArrayDTO);
        for (Long id : idArrayDTO.getIds()) {
    <%- include('../../common/delete_template', {viaService: viaService}); -%>
        }
        return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(applicationName, <%= enableTranslation %>, ENTITY_NAME, idArrayDTO.getIds().toString())).build();
    }
<%_ } _%>

<%_ if (searchEngine !== false) { _%>

    /**
     * {@code SEARCH  /_search/<%= entityApiUrl %>?query=:query} : search for the <%= entityInstance %> corresponding
     * to the query.
     *
     * @param query the query of the <%= entityInstance %> search.
    <%_ if (pagination !== 'no') { _%>
     * @param pageable the pagination information.
       <%_ if (reactive) { _%>
     * @param request a {@link ServerHttpRequest} request.
        <%_ } _%>
    <%_ } _%>
     * @return the result of the search.
     */
    <%_ if (requiredRoleForRead) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForRead %> + "\")") //@Trifon
    <%_ } _%>
    @GetMapping("/_search/<%= entityApiUrl %>")<%- include('../../common/search_template', {asEntity, asDto, viaService}); -%>

<%_ } _%>

<%_ for (idx in fields) {
      const fieldType = fields[idx].fieldType;
      const fieldTypeBlobContent = fields[idx].fieldTypeBlobContent;
      const fieldName = fields[idx].fieldName;
      const fieldInJavaBeanMethod = fields[idx].fieldInJavaBeanMethod;
      if (fields[idx].fieldValidate === true && fields[idx].fieldValidateRules.includes('unique')) { _%>
	/**
	 * Import <%= entityInstance %> by <%= fieldName %> from .csv file
	 * 
	 * @param file
	 * @return
	 * @throws URISyntaxException, IOException
	 */
	@PostMapping("/<%= entityApiUrl %>/import/by-<%= fieldName %>.csv")
    <%_ if (requiredRoleForCreate) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")") //@Trifon
    <%_ } _%>
	public ResponseEntity<String> import<%= entityClass %>By<%= fieldInJavaBeanMethod %>(@RequestParam("file") MultipartFile file) throws URISyntaxException, IOException {
		if (!file.isEmpty()) {
			log.debug("REST request to import <%= entityClass %> by <%= fieldName %> with file: {}", file);
			BufferedReader buffReader = null;
			try {
				// Open the file
				buffReader = new BufferedReader(new InputStreamReader(file.getInputStream()));

				int numImportedRecords = 0;
				boolean isFirstLine = true;
				boolean useMapMethodForImport = false;
				String strLine;
				// Read file line by line
				while ((strLine = buffReader.readLine()) != null) {
					if (isFirstLine) {  // TODO - Add it as parameter of REST request.
						isFirstLine = false;
					} else if (strLine.startsWith("#")) {
						useMapMethodForImport = true;
					} else {
						String[] columns = strLine.split(";"); // TODO - Add separator as parameter of REST request.
						<%= instanceType %> <%= instanceName %> = null;
						
						if (useMapMethodForImport) {
							Map<String, String> columnNameValueMap = <%= entityInstance %>Service.columnsToNameValueMap(columns);
							<%= instanceName %> = <%= entityInstance %>Service.import<%= entityClass %>By<%= fieldInJavaBeanMethod %>(columnNameValueMap);
						} else {
							<%= instanceName %> = <%= entityInstance %>Service.import<%= entityClass %>By<%= fieldInJavaBeanMethod %>(columns);
						}
						<%= instanceName %> = <%= entityInstance %>Service.save(<%= instanceName %>);

						numImportedRecords = numImportedRecords + 1;
					}
				}
				return ResponseEntity.ok().body(String.format("Imported #%s records from file %s", numImportedRecords, file.getOriginalFilename()));
			} finally {
				if (buffReader != null) {
					buffReader.close();
				}
			}
		} else {
			return ResponseEntity.ok().body("File is empty, no records were imported.");
		}
	}

<%_ }
}
	//@Trifon - multi-unique
if (hasMultiUniqueConstraints(multiUniqueConstraints)) {
	for (idx in multiUniqueConstraints) {
		let findByNames = multiUniqueFindByNames(multiUniqueConstraints[idx]);
//		let findByParameters = multiUniqueFindByParameters(multiUniqueConstraints[idx], fields);
		let findByParameterNamesOnly = multiUniqueFindByParameterNamesOnly(multiUniqueConstraints[idx]);
		let findByParameterNamesOnlyForLog = multiUniqueFindByParameterNamesOnlyForLog(multiUniqueConstraints[idx]);
//		let findByOtherEntity = multiUniqueFindByOtherEntity(multiUniqueConstraints[idx], entityClass, fields);
		let resourceUrlName = toResourceUrlName(multiUniqueConstraints[idx]);
_%>
	/**
	 * Import <%= entityInstance %> by <%= findByNames %> from .csv file
	 * 
	 * @param file
	 * @return
	 * @throws URISyntaxException, IOException
	 */
	@PostMapping("/<%= entityApiUrl %>/import/by-<%= resourceUrlName %>.csv")
    <%_ if (requiredRoleForCreate) { _%>
    @PreAuthorize("hasAuthority(\"" + AuthoritiesConstants.<%= requiredRoleForCreate %> + "\")") //@Trifon
    <%_ } _%>
	public ResponseEntity<String> import<%= entityClass %>By<%= findByNames %>(@RequestParam("file") MultipartFile file) throws URISyntaxException, IOException {
		if (!file.isEmpty()) {
			log.debug("REST request to import <%= entityClass %> by <%= findByNames %> with file: {}", file);
			BufferedReader buffReader = null;
			try {
				// Open the file
				buffReader = new BufferedReader(new InputStreamReader(file.getInputStream()));

				int numImportedRecords = 0;
				boolean isFirstLine = true;
				boolean useMapMethodForImport = false;
				String strLine;
				// Read file line by line
				while ((strLine = buffReader.readLine()) != null) {
					if (isFirstLine) {  // TODO - Add it as parameter of REST request.
						isFirstLine = false;
					} else if (strLine.startsWith("#")) {
						useMapMethodForImport = true;
					} else {
						String[] columns = strLine.split(";"); // TODO - Add separator as parameter of REST request.
						<%= instanceType %> <%= instanceName %> = null;
						
						if (useMapMethodForImport) {
							Map<String, String> columnNameValueMap = <%= entityInstance %>Service.columnsToNameValueMap(columns);
							<%= instanceName %> = <%= entityInstance %>Service.import<%= entityClass %>By<%= findByNames %>(columnNameValueMap);
						} else {
							<%= instanceName %> = <%= entityInstance %>Service.import<%= entityClass %>By<%= findByNames %>(columns);
						}
						<%= instanceName %> = <%= entityInstance %>Service.save(<%= instanceName %>);

						numImportedRecords = numImportedRecords + 1;
					}
				}
				return ResponseEntity.ok().body(String.format("Imported #%s records from file %s", numImportedRecords, file.getOriginalFilename()));
			} finally {
				if (buffReader != null) {
					buffReader.close();
				}
			}
		} else {
			return ResponseEntity.ok().body("File is empty, no records were imported.");
		}
	}

<%_ } } _%>
}
